#!/usr/bin/env bash
# This script was generated by bashly 1.2.12 (https://bashly.dev)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
devcli_usage() {
  printf "devcli - Development Utilities\n\n"

  printf "%s\n" "$(bold "Usage:")"
  printf "  devcli COMMAND\n"
  printf "  devcli [COMMAND] --help | -h\n"
  printf "  devcli --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Display the weather forecast for the current location.\n" "$(green "weather")             "
  printf "  %s   Build the project.\n" "$(green "build")               "
  printf "  %s   Run the project locally.\n" "$(green "local-run")           "
  printf "  %s   Run code scanning tools on the project.\n" "$(green "code-scan")           "
  printf "  %s   Run Black code formatter on the project.\n" "$(green "code-scan black")     "
  printf "  %s   Run ASH code scanner on the project.\n" "$(green "code-scan ash")       "
  printf "  %s   Run Trufflehog code scanner on the project.\n" "$(green "code-scan trufflehog")"
  printf "  %s   Run mypy type checker on the project.\n" "$(green "code-scan mypy")      "
  printf "  %s   Run Flake8 linter on the project.\n" "$(green "code-scan flake8")    "
  printf "  %s   Run tests on the project.\n" "$(green "test")                "
  printf "  %s   Generate bash completions\n" "$(green "completions")         "
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "$(magenta "--version, -v")"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
devcli_weather_usage() {
  printf "devcli weather - Display the weather forecast for the current location.\n\n"

  printf "%s\n" "$(bold "Usage:")"
  printf "  devcli weather\n"
  printf "  devcli weather --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
devcli_build_usage() {
  printf "devcli build - Build the project.\n\n"

  printf "%s\n" "$(bold "Usage:")"
  printf "  devcli build VERSION\n"
  printf "  devcli build --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "VERSION")"
    printf "    The version to build the project with.\n"
    echo

  fi
}

# :command.usage
devcli_local_run_usage() {
  printf "devcli local-run - Run the project locally.\n\n"

  printf "%s\n" "$(bold "Usage:")"
  printf "  devcli local-run\n"
  printf "  devcli local-run --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
devcli_code_scan_usage() {
  printf "devcli code-scan - Run code scanning tools on the project.\n\n"
  printf "Alias: cs\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  devcli code-scan COMMAND\n"
  printf "  devcli code-scan [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Run Black code formatter on the project.\n" "$(green "black")     "
  printf "  %s   Run ASH code scanner on the project.\n" "$(green "ash")       "
  printf "  %s   Run Trufflehog code scanner on the project.\n" "$(green "trufflehog")"
  printf "  %s   Run mypy type checker on the project.\n" "$(green "mypy")      "
  printf "  %s   Run Flake8 linter on the project.\n" "$(green "flake8")    "
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
devcli_code_scan_black_usage() {
  printf "devcli code-scan black - Run Black code formatter on the project.\n\n"

  printf "%s\n" "$(bold "Usage:")"
  printf "  devcli code-scan black\n"
  printf "  devcli code-scan black --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
devcli_code_scan_ash_usage() {
  printf "devcli code-scan ash - Run ASH code scanner on the project.\n\n"

  printf "%s\n" "$(bold "Usage:")"
  printf "  devcli code-scan ash\n"
  printf "  devcli code-scan ash --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
devcli_code_scan_trufflehog_usage() {
  printf "devcli code-scan trufflehog - Run Trufflehog code scanner on the project.\n\n"

  printf "%s\n" "$(bold "Usage:")"
  printf "  devcli code-scan trufflehog\n"
  printf "  devcli code-scan trufflehog --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
devcli_code_scan_mypy_usage() {
  printf "devcli code-scan mypy - Run mypy type checker on the project.\n\n"

  printf "%s\n" "$(bold "Usage:")"
  printf "  devcli code-scan mypy\n"
  printf "  devcli code-scan mypy --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
devcli_code_scan_flake8_usage() {
  printf "devcli code-scan flake8 - Run Flake8 linter on the project.\n\n"

  printf "%s\n" "$(bold "Usage:")"
  printf "  devcli code-scan flake8\n"
  printf "  devcli code-scan flake8 --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
devcli_test_usage() {
  printf "devcli test - Run tests on the project.\n\n"

  printf "%s\n" "$(bold "Usage:")"
  printf "  devcli test COMMAND\n"
  printf "  devcli test [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Run unit tests on the project.\n" "$(green "unit")       "
  printf "  %s   Run integration tests on the project.\n" "$(green "integration")"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
devcli_test_unit_usage() {
  printf "devcli test unit - Run unit tests on the project.\n\n"

  printf "%s\n" "$(bold "Usage:")"
  printf "  devcli test unit\n"
  printf "  devcli test unit --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
devcli_test_integration_usage() {
  printf "devcli test integration - Run integration tests on the project.\n\n"

  printf "%s\n" "$(bold "Usage:")"
  printf "  devcli test integration\n"
  printf "  devcli test integration --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
devcli_completions_usage() {
  if [[ -n $long_usage ]]; then
    printf "devcli completions\n\n"
    printf "  Generate bash completions\n  Usage: eval \"\$(devcli completions)\"\n\n"
  else
    printf "devcli completions - Generate bash completions\n\n"
  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  devcli completions\n"
  printf "  devcli completions --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(magenta "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.user_lib
# src/lib/add_once_to_file.sh
#!/usr/bin/env bash

add_once_to_file() {
  local text=$1
  local target_file=$2

  if [[ ! -f "$target_file" ]]; then
    touch "$target_file"
  fi

  if ! grep -Fq "$text" "$target_file"
  then
    echo "$text" >>"$target_file"
  fi
}

# src/lib/colors.sh

enable_auto_colors() {
  if [[ -z ${NO_COLOR+x} && ! -t 1 ]]; then
    NO_COLOR=1
  fi
}

print_in_color() {
  local color="$1"
  shift
  if [[ "${NO_COLOR:-}" == "" ]]; then
    printf "$color%b\e[0m\n" "$*"
  else
    printf "%b\n" "$*"
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
black() { print_in_color "\e[30m" "$*"; }
white() { print_in_color "\e[37m" "$*"; }

bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }

red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
black_bold() { print_in_color "\e[1;30m" "$*"; }
white_bold() { print_in_color "\e[1;37m" "$*"; }

red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }
black_underlined() { print_in_color "\e[4;30m" "$*"; }
white_underlined() { print_in_color "\e[4;37m" "$*"; }

print_in_color() {
  local color="$1"
  shift
  if [[ -z ${NO_COLOR+x} ]]; then
    printf "$color%b\e[0m" "$*";
  else
    printf "%b" "$*";
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
white() { print_in_color "\e[37m" "$*"; }
white_dim() { print_in_color "\e[2;37m" "$*"; }
bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }
red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
white_bold() { print_in_color "\e[1;37m" "$*"; }
red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }

println_in_color() {
  local color="$1"
  shift
  if [[ -z ${NO_COLOR+x} ]]; then
    printf "$color%b\e[0m\n" "$*";
  else
    printf "%b\n" "$*";
  fi
}

red_ln() { println_in_color "\e[31m" "$*"; }
green_ln() { println_in_color "\e[32m" "$*"; }
yellow_ln() { println_in_color "\e[33m" "$*"; }
blue_ln() { println_in_color "\e[34m" "$*"; }
magenta_ln() { println_in_color "\e[35m" "$*"; }
cyan_ln() { println_in_color "\e[36m" "$*"; }
white_ln() { println_in_color "\e[37m" "$*"; }
white_dim_ln() { println_in_color "\e[2;37m" "$*"; }
bold_ln() { println_in_color "\e[1m" "$*"; }
underlined_ln() { println_in_color "\e[4m" "$*"; }
red_bold_ln() { println_in_color "\e[1;31m" "$*"; }
green_bold_ln() { println_in_color "\e[1;32m" "$*"; }
yellow_bold_ln() { println_in_color "\e[1;33m" "$*"; }
blue_bold_ln() { println_in_color "\e[1;34m" "$*"; }
magenta_bold_ln() { println_in_color "\e[1;35m" "$*"; }
cyan_bold_ln() { println_in_color "\e[1;36m" "$*"; }
white_bold_ln() { println_in_color "\e[1;37m" "$*"; }
red_underlined_ln() { println_in_color "\e[4;31m" "$*"; }
green_underlined_ln() { println_in_color "\e[4;32m" "$*"; }
yellow_underlined_ln() { println_in_color "\e[4;33m" "$*"; }
blue_underlined_ln() { println_in_color "\e[4;34m" "$*"; }
magenta_underlined_ln() { println_in_color "\e[4;35m" "$*"; }
cyan_underlined_ln() { println_in_color "\e[4;36m" "$*"; }

# src/lib/environment.sh
#!/usr/bin/env bash

function __osx() {
  # __osx - return if we are running in 'Darwin' (macos)
  [[ $(uname) == "Darwin" ]]
}

function __ubuntu() {
  [[ $(uname) == "Linux" && $(cat /etc/issue | grep -i ubuntu) ]]
}

function noop() {
  echo 'noop' >/dev/null
}

# src/lib/ini_config.sh
#!/usr/bin/env bash

# -------------------------------------------------------------------------------- #
# Description                                                                      #
# -------------------------------------------------------------------------------- #
# A 'complete' ini file parsers written in pure bash (4), it was written for no    #
# other reason that one did not exist. It is completely pointless apart from some  #
# clever tricks.                                                                   #
# -------------------------------------------------------------------------------- #

# -------------------------------------------------------------------------------- #
# Global Variables                                                                 #
# -------------------------------------------------------------------------------- #
# Global variables which can be set by the calling script, but need to be declared #
# here also to ensure the script is clean and error free.                          #
#                                                                                  #
# case_sensitive_sections - should section names be case sensitive                 #
# case_sensitive_keys     - should key names be case sensitive                     #
# show_config_warnings    - should we show config warnings                         #
# show_config_errors      - should we show config errors                           #
# -------------------------------------------------------------------------------- #

declare case_sensitive_sections
declare case_sensitive_keys
declare show_config_warnings
declare show_config_errors

# -------------------------------------------------------------------------------- #
# Default Section                                                                  #
# -------------------------------------------------------------------------------- #
# Any values that are found outside of a defined section need to be put somewhere  #
# so they can be recalled as needed. Sections is set up with a 'default' for this  #
# purpose.                                                                         #
# -------------------------------------------------------------------------------- #

DEFAULT_SECTION='default'

sections=( "${DEFAULT_SECTION}" )

# -------------------------------------------------------------------------------- #
# Local Variables                                                                  #
# -------------------------------------------------------------------------------- #
# The local variables which can be overridden by the global variables above.       #
#                                                                                  #
# local_case_sensitive_sections - should section names be case sensitive           #
# local_case_sensitive_keys     - should key names be case sensitive               #
# local_show_config_warnings    - should we show config warnings                   #
# local_show_config_errors      - should we show config errors                     #
# -------------------------------------------------------------------------------- #

local_case_sensitive_sections=true
local_case_sensitive_keys=true
local_show_config_warnings=true
local_show_config_errors=true

# -------------------------------------------------------------------------------- #
# Set Global Variables                                                             #
# -------------------------------------------------------------------------------- #
# Check to see if the global overrides are set and if so, override the defaults.   #
#                                                                                  #
# Error checking is in place to ensure that the override contains a valid value of #
# true or false, anything else is ignored.
# -------------------------------------------------------------------------------- #

function setup_global_variables
{
    if [[ -n "${case_sensitive_sections}" ]] && [[ "${case_sensitive_sections}" = false || "${case_sensitive_sections}" = true ]]; then
         local_case_sensitive_sections=$case_sensitive_sections
    fi

    if [[ -n "${case_sensitive_keys}" ]] && [[ "${case_sensitive_keys}" = false || "${case_sensitive_keys}" = true ]]; then
         local_case_sensitive_keys=$case_sensitive_keys
    fi

    if [[ -n "${show_config_warnings}" ]] && [[ "${show_config_warnings}" = false || "${show_config_warnings}" = true ]]; then
         local_show_config_warnings=$show_config_warnings
    fi

    if [[ -n "${show_config_errors}" ]] && [[ "${show_config_errors}" = false || "${show_config_errors}" = true ]]; then
         local_show_config_errors=$show_config_errors
    fi
}

# -------------------------------------------------------------------------------- #
# in Array                                                                         #
# -------------------------------------------------------------------------------- #
# A function to check to see if a given value exists in a given array.             #
# -------------------------------------------------------------------------------- #

function in_array()
{
    local haystack="${1}[@]"
    local needle=${2}

    for i in ${!haystack}; do
        if [[ ${i} == "${needle}" ]]; then
            return 0
        fi
    done
    return 1
}

# -------------------------------------------------------------------------------- #
# Show Warning                                                                     #
# -------------------------------------------------------------------------------- #
# A wrapper to display any configuration warnings, taking into account if the      #
# local_show_config_warnings flag is set to true.                                  #
# -------------------------------------------------------------------------------- #

function show_warning()
{
    if [[ "${local_show_config_warnings}" = true ]]; then
        format=$1
        shift;

        # shellcheck disable=SC2059
        printf "[ WARNING ] ${format}" "$@";
    fi
}

# -------------------------------------------------------------------------------- #
# Show Error                                                                       #
# -------------------------------------------------------------------------------- #
# A wrapper to display any configuration errors, taking into account if the        #
# local_show_config_errorss flag is set to true.                                   #
# -------------------------------------------------------------------------------- #

function show_error()
{
    if [[ "${local_show_config_errors}" = true ]]; then
        format=$1
        shift;

        # shellcheck disable=SC2059
        printf "[ ERROR ] ${format}" "$@";
    fi
}

# -------------------------------------------------------------------------------- #
# Process Section Name                                                             #
# -------------------------------------------------------------------------------- #
# Once we have located a section name within the given config file, we need to     #
# 'cleanse' the value.                                                             #
# -------------------------------------------------------------------------------- #

function process_section_name()
{
    local section=$1

    section="${section##*( )}"                                                     # Remove leading spaces
    section="${section%%*( )}"                                                     # Remove trailing spaces
    section=$(echo -e "${section}" | tr -s '[:punct:] [:blank:]' '_')              # Replace all :punct: and :blank: with underscore and squish
    section=$(echo -e "${section}" | sed 's/[^a-zA-Z0-9_]//g')                     # Remove non-alphanumberics (except underscore)

    if [[ "${local_case_sensitive_sections}" = false ]]; then
        section=$(echo -e "${section}" | tr '[:upper:]' '[:lower:]')               # Lowercase the section name
    fi
    echo "${section}"
}

# -------------------------------------------------------------------------------- #
# Process Key Name                                                                 #
# -------------------------------------------------------------------------------- #
# Once we have located a key name on a given line, we need to 'cleanse' the value. #
# -------------------------------------------------------------------------------- #

function process_key_name()
{
    local key=$1

    key="${key##*( )}"                                                             # Remove leading spaces
    key="${key%%*( )}"                                                             # Remove trailing spaces
    key=$(echo -e "${key}" | tr -s '[:punct:] [:blank:]' '_')                      # Replace all :punct: and :blank: with underscore and squish
    key=$(echo -e "${key}" | sed 's/[^a-zA-Z0-9_]//g')                             # Remove non-alphanumberics (except underscore)

    if [[ "${local_case_sensitive_keys}" = false ]]; then
        key=$(echo -e "${key}" | tr '[:upper:]' '[:lower:]')                       # Lowercase the section name
    fi
    echo "${key}"
}

# -------------------------------------------------------------------------------- #
# Process Value                                                                    #
# -------------------------------------------------------------------------------- #
# Once we have located a value attached to a key, we need to 'cleanse' the value.  #
# -------------------------------------------------------------------------------- #

function process_value()
{
    local value=$1

    value="${value%%\;*}"                                                          # Remove in line right comments
    value="${value%%\#*}"                                                          # Remove in line right comments
    value="${value##*( )}"                                                         # Remove leading spaces
    value="${value%%*( )}"                                                         # Remove trailing spaces

    value=$(escape_string "$value")

    echo "${value}"
}

# -------------------------------------------------------------------------------- #
# Escape string                                                                    #
# -------------------------------------------------------------------------------- #
# Replace ' with SINGLE_QUOTE to avoid issues with eval.                           #
# -------------------------------------------------------------------------------- #

function escape_string()
{
    local clean

    clean=${1//\'/SINGLE_QUOTE}
    echo "${clean}"
}

# -------------------------------------------------------------------------------- #
# Un-Escape string                                                                 #
# -------------------------------------------------------------------------------- #
# Convert SINGLE_QUOTE back to ' when returning the value to the caller.           #
# -------------------------------------------------------------------------------- #

function unescape_string()
{
    local orig

    orig=${1//SINGLE_QUOTE/\'}
    echo "${orig}"
}

# -------------------------------------------------------------------------------- #
# Parse ini file                                                                   #
# -------------------------------------------------------------------------------- #
# Read a named file line by line and process as required.                          #
# -------------------------------------------------------------------------------- #

function process_ini_file()
{
    local line_number=0
    local section="${DEFAULT_SECTION}"
    local key_array_name=''

    setup_global_variables

    shopt -s extglob
#    setopt extended_glob

    while read -r line; do
        line_number=$((line_number+1))

        if [[ $line =~ ^# || -z $line ]]; then                                 # Ignore comments / empty lines
            continue;
        fi

        if [[ $line =~ ^"["(.+)"]"$ ]]; then                                   # Match pattern for a 'section'
            section=$(process_section_name "${BASH_REMATCH[1]}")

            if ! in_array sections "${section}"; then
                eval "${section}_keys=()"                                      # Use eval to declare the keys array
                eval "${section}_values=()"                                    # Use eval to declare the values array
                sections+=("${section}")                                       # Add the section name to the list
            fi
        elif [[ $line =~ ^(.*)"="(.*) ]]; then                                 # Match patter for a key=value pair
            key=$(process_key_name "${BASH_REMATCH[1]}")
            value=$(process_value "${BASH_REMATCH[2]}")

            if [[ -z ${key} ]]; then
                show_error 'line %d: No key name\n' "${line_number}"
            elif [[ -z ${value} ]]; then
                show_error 'line %d: No value\n' "${line_number}"
            else
                if [[ "${section}" == "${DEFAULT_SECTION}" ]]; then
                    show_warning '%s=%s - Defined on line %s before first section - added to "%s" group\n' "${key}" "${value}" "${line_number}" "${DEFAULT_SECTION}"
                fi

                eval key_array_name="${section}_keys"

                if in_array "${key_array_name}" "${key}"; then
                    show_warning 'key %s - Defined multiple times within section %s\n' "${key}" "${section}"
                fi
                eval "${section}_keys+=(${key})"                               # Use eval to add to the keys array
                eval "${section}_values+=('${value}')"                         # Use eval to add to the values array
                eval "${section}_${key}='${value}'"                            # Use eval to declare a variable
            fi
        fi
    done < "$1"
}

# -------------------------------------------------------------------------------- #
# Get Value                                                                        #
# -------------------------------------------------------------------------------- #
# Retrieve a value for a specific key from a named section.                        #
# -------------------------------------------------------------------------------- #

function get_value()
{
    local section=''
    local key=''
    local value=''
    local keys=''
    local values=''

    section=$(process_section_name "${1}")
    key=$(process_key_name "${2}")

    eval "keys=( \"\${${section}_keys[@]}\" )"
    eval "values=( \"\${${section}_values[@]}\" )"

    for i in "${!keys[@]}"; do
        if [[ "${keys[$i]}" = "${key}" ]]; then
            orig=$(unescape_string "${values[$i]}")
            printf '%s' "${orig}"
        fi
    done
}

# -------------------------------------------------------------------------------- #
# Display Config                                                                   #
# -------------------------------------------------------------------------------- #
# Display all of the post processed configuration.                                 #
#                                                                                  #
# NOTE: This is without comments etec.                                             #
# -------------------------------------------------------------------------------- #

function display_config()
{
    local section=''
    local key=''
    local value=''

    for s in "${!sections[@]}"; do
        section=${sections[$s]}

        printf '[%s]\n' "${section}"

        eval "keys=( \"\${${section}_keys[@]}\" )"
        eval "values=( \"\${${section}_values[@]}\" )"

        for i in "${!keys[@]}"; do
            orig=$(unescape_string "${values[$i]}")
            printf '%s=%s\n' "${keys[$i]}" "${orig}"
        done
    printf '\n'
    done
}

# -------------------------------------------------------------------------------- #
# Display Config by Section                                                        #
# -------------------------------------------------------------------------------- #
# Display all of the post processed configuration for a given section.             #
#                                                                                  #
# NOTE: This is without comments etec.                                             #
# -------------------------------------------------------------------------------- #

function display_config_by_section()
{
    local section=$1
    local key=''
    local value=''
    local keys=''
    local values=''

    printf '[%s]\n' "${section}"

    eval "keys=( \"\${${section}_keys[@]}\" )"
    eval "values=( \"\${${section}_values[@]}\" )"

    for i in "${!keys[@]}"; do
        orig=$(unescape_string "${values[$i]}")
        printf '%s=%s\n' "${keys[$i]}" "${orig}"
    done
    printf '\n'
}

# -------------------------------------------------------------------------------- #
# End of Script                                                                    #
# -------------------------------------------------------------------------------- #
# This is the end - nothing more to see here.                                      #
# -------------------------------------------------------------------------------- #

# src/lib/parse_version_string.sh
#!/usr/bin/env bash

function get_version_major() {

  IFS='.' read -ra version_arr <<< "$1"
  echo "${version_arr[0]}"
}

function get_version_minor() {

  IFS='.' read -ra version_arr <<< "$1"
  echo "${version_arr[1]}"
}

function get_version_patch() {

  IFS='.' read -ra version_arr <<< "$1"
  echo "${version_arr[2]}"
}

# src/lib/redact_string.sh
#!/usr/bin/env bash

set -euo pipefail

function _redact_string() {
  local target_string
  target_string=$1

  local num_visisble_chars
  num_visisble_chars=$2

  local count
  count=$((${#target_string}-$num_visisble_chars))

  local stars
  stars=$(printf '*%.0s' echo $(eval echo {0..$count}))

  local is_left
  is_left=$3

  local sed_str
  if [[ $is_left == "true" ]]; then
    sed_str="s/^.\{${count}\}/${stars}/g"
  else
    sed_str="s/.\{${count}\}$/${stars}/g"
  fi

  target_string_masked=$(echo $target_string | sed -e $sed_str)
  echo $target_string_masked
}

function redact_string_right() {
  _redact_string $1 $2 false
}

function redact_string_left() {
  _redact_string $1 $2 true
}

set +euo pipefail

# src/lib/send_completions.sh
send_completions() {
  echo $'# devcli completion                                        -*- shell-script -*-'
  echo $''
  echo $'# This bash completions script was generated by'
  echo $'# completely (https://github.com/dannyben/completely)'
  echo $'# Modifying it manually is not recommended'
  echo $''
  echo $'_devcli_completions_filter() {'
  echo $'  local words="$1"'
  echo $'  local cur=${COMP_WORDS[COMP_CWORD]}'
  echo $'  local result=()'
  echo $''
  echo $'  if [[ "${cur:0:1}" == "-" ]]; then'
  echo $'    echo "$words"'
  echo $''
  echo $'  else'
  echo $'    for word in $words; do'
  echo $'      [[ "${word:0:1}" != "-" ]] && result+=("$word")'
  echo $'    done'
  echo $''
  echo $'    echo "${result[*]}"'
  echo $''
  echo $'  fi'
  echo $'}'
  echo $''
  echo $'_devcli_completions() {'
  echo $'  local cur=${COMP_WORDS[COMP_CWORD]}'
  echo $'  local compwords=("${COMP_WORDS[@]:1:$COMP_CWORD-1}")'
  echo $'  local compline="${compwords[*]}"'
  echo $''
  echo $'  case "$compline" in'
  echo $'    \'test integration\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_devcli_completions_filter "--help -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'code-scan black\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_devcli_completions_filter "--help -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'code-scan ash\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_devcli_completions_filter "--help -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'completions\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_devcli_completions_filter "--help -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'code-scan\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_devcli_completions_filter "--help -h ash black")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'test unit\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_devcli_completions_filter "--help -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'weather\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_devcli_completions_filter "--help --skip-if-already-printed-today -h -s")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'build\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_devcli_completions_filter "--help -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'test\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_devcli_completions_filter "--help -h integration unit")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    *)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_devcli_completions_filter "--help --version -h -v build code-scan completions test weather")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'  esac'
  echo $'} &&'
  echo $'  complete -F _devcli_completions devcli'
  echo $''
  echo $'# ex: filetype=sh'
}

# src/lib/source_dir.sh
#!/usr/bin/env bash

source_dir() {
  SOURCE="${BASH_SOURCE[0]:-$0}"
  while [ -L "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
    DIR="$(cd -P "$(dirname -- "$SOURCE")" &>/dev/null && pwd 2>/dev/null)"
    SOURCE="$(readlink -- "$SOURCE")"
    [[ $SOURCE != /* ]] && SOURCE="${DIR}/${SOURCE}" # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
  done
  DIR="$(cd -P "$(dirname -- "$SOURCE")" &>/dev/null && pwd 2>/dev/null)"
  echo $DIR
}

# src/lib/yaml.sh
yaml_load() {
  local prefix=$2
  local s='[[:space:]]*' w='[a-zA-Z0-9_]*'
  local fs

  fs=$(echo @ | tr @ '\034')

  sed -ne "s|^\($s\):|\1|" \
    -e "s|^\($s\)\($w\)$s:${s}[\"']\(.*\)[\"']$s\$|\1$fs\2$fs\3|p" \
    -e "s|^\($s\)\($w\)$s:$s\(.*\)$s\$|\1$fs\2$fs\3|p" "$1" |
    awk -F"$fs" '{
      indent = length($1)/2;
      vname[indent] = $2;
      for (i in vname) {if (i > indent) {delete vname[i]}}
      if (length($3) > 0) {
         vn=""; for (i=0; i<indent; i++) {vn=(vn)(vname[i])("_")}
         printf("%s%s%s=\"%s\"\n", "'"$prefix"'",vn, $2, $3);
      }
    }'
}

# :command.command_functions
# :command.function
devcli_weather_command() {

  # src/weather_command.sh
  #!/usr/bin/env bash

  curl --max-time 2 'wttr.in/'

}

# :command.function
devcli_build_command() {

  # src/build_command.sh
  #!/usr/bin/env bash

  version=${args["version"]}

  set -e

  docker buildx build --platform linux/amd64 --push \
    -t 386757133934.dkr.ecr.us-east-1.amazonaws.com/javier/cicd-strawman-ui:latest \
    -t 386757133934.dkr.ecr.us-east-1.amazonaws.com/javier/cicd-strawman-ui:"$version" .

}

# :command.function
devcli_local_run_command() {

  # src/local_run_command.sh
  echo "# This file is located at 'src/local_run_command.sh'."
  echo "# It contains the implementation for the 'ocean local-run' command."
  echo "# The code you write here will be wrapped by a function named 'ocean_local_run_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

}

# :command.function
devcli_code_scan_black_command() {

  # src/code_scan_black_command.sh
  #!/usr/bin/env bash

  echo "# This file is located at 'src/code_scan_black_command.sh'."
  echo "# It contains the implementation for the 'devcli code-scan black' command."
  echo "# The code you write here will be wrapped by a function named 'devcli_code_scan_black_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

  red_ln "Not yet implemented."
  exit 1

}

# :command.function
devcli_code_scan_ash_command() {

  # src/code_scan_ash_command.sh
  #!/usr/bin/env bash

  #inspect_args

  # check if ash is installed
  if ! command -v ash &>/dev/null; then
    red_ln "ASH is not installed."
    exit 1
  fi

  set +euo pipefail

  ash --build-target ci --output-dir .ash-results/ --source-dir .
  ret_val=$?

  if [ "$ret_val" -ne 0 ]; then
    cat .ash-results/aggregated_results.txt
    red_bold_ln "ASH scan failed."

    exit "$ret_val"
  else
    green_ln "ASH scan completed successfully."
    white_bold_ln "ASH scan results saved to .ash-results/aggregated_results.txt"
  fi

}

# :command.function
devcli_code_scan_trufflehog_command() {

  # src/code_scan_trufflehog_command.sh
  #!/usr/bin/env bash

  echo "# This file is located at 'src/code_scan_trufflehog_command.sh'."
  echo "# It contains the implementation for the 'devcli code-scan trufflehog' command."
  echo "# The code you write here will be wrapped by a function named 'devcli_code_scan_trufflehog_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

  red_ln "Not yet implemented."
  exit 1

}

# :command.function
devcli_code_scan_mypy_command() {

  # src/code_scan_mypy_command.sh
  echo "# This file is located at 'src/code_scan_mypy_command.sh'."
  echo "# It contains the implementation for the 'devcli code-scan mypy' command."
  echo "# The code you write here will be wrapped by a function named 'devcli_code_scan_mypy_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

}

# :command.function
devcli_code_scan_flake8_command() {

  # src/code_scan_flake8_command.sh
  echo "# This file is located at 'src/code_scan_flake8_command.sh'."
  echo "# It contains the implementation for the 'devcli code-scan flake8' command."
  echo "# The code you write here will be wrapped by a function named 'devcli_code_scan_flake8_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

}

# :command.function
devcli_test_unit_command() {

  # src/test_unit_command.sh
  #!/usr/bin/env bash

  #inspect_args

  poetry run pytest --cov=src \
    --cov-branch \
    --cov-report term \
    --cov-report=term-missing \
    --cov-report=xml:.test-results/coverage.xml \
    --junitxml=.test-results/test-results.xml \
    .

  if [[ $? != 0 ]]; then
    red_ln "Unit tests failed."
    exit 1
  fi

  green_ln "Unit tests passed."

}

# :command.function
devcli_test_integration_command() {

  # src/test_integration_command.sh
  #!/usr/bin/env bash

  echo "# This file is located at 'src/test_integration_command.sh'."
  echo "# It contains the implementation for the 'devcli test integration' command."
  echo "# The code you write here will be wrapped by a function named 'devcli_test_integration_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

  red_ln "Not yet implemented."
  exit 1

}

# :command.function
devcli_completions_command() {

  # src/completions_command.sh
  send_completions

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        devcli_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    weather)
      action="weather"
      shift
      devcli_weather_parse_requirements "$@"
      shift $#
      ;;

    build)
      action="build"
      shift
      devcli_build_parse_requirements "$@"
      shift $#
      ;;

    local-run)
      action="local-run"
      shift
      devcli_local_run_parse_requirements "$@"
      shift $#
      ;;

    code-scan | cs)
      action="code-scan"
      shift
      devcli_code_scan_parse_requirements "$@"
      shift $#
      ;;

    test)
      action="test"
      shift
      devcli_test_parse_requirements "$@"
      shift $#
      ;;

    completions)
      action="completions"
      shift
      devcli_completions_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      devcli_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
devcli_weather_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        devcli_weather_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="weather"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
devcli_build_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        devcli_build_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="build"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['version']+x} ]]; then
          args['version']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['version']+x} ]]; then
    printf "missing required argument: VERSION\nusage: devcli build VERSION\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
devcli_local_run_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        devcli_local_run_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="local-run"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
devcli_code_scan_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        devcli_code_scan_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    black)
      action="black"
      shift
      devcli_code_scan_black_parse_requirements "$@"
      shift $#
      ;;

    ash)
      action="ash"
      shift
      devcli_code_scan_ash_parse_requirements "$@"
      shift $#
      ;;

    trufflehog)
      action="trufflehog"
      shift
      devcli_code_scan_trufflehog_parse_requirements "$@"
      shift $#
      ;;

    mypy)
      action="mypy"
      shift
      devcli_code_scan_mypy_parse_requirements "$@"
      shift $#
      ;;

    flake8)
      action="flake8"
      shift
      devcli_code_scan_flake8_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      devcli_code_scan_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
devcli_code_scan_black_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        devcli_code_scan_black_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="code-scan black"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
devcli_code_scan_ash_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        devcli_code_scan_ash_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="code-scan ash"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
devcli_code_scan_trufflehog_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        devcli_code_scan_trufflehog_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="code-scan trufflehog"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
devcli_code_scan_mypy_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        devcli_code_scan_mypy_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="code-scan mypy"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
devcli_code_scan_flake8_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        devcli_code_scan_flake8_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="code-scan flake8"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
devcli_test_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        devcli_test_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    unit)
      action="unit"
      shift
      devcli_test_unit_parse_requirements "$@"
      shift $#
      ;;

    integration)
      action="integration"
      shift
      devcli_test_integration_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      devcli_test_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
devcli_test_unit_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        devcli_test_unit_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="test unit"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
devcli_test_integration_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        devcli_test_integration_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="test integration"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
devcli_completions_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        devcli_completions_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="completions"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.initialize
initialize() {
  declare -g version="0.1.0"
  set -e

  # src/initialize.sh

}

# :command.run
run() {
  # :command.globals
  declare -g long_usage=''
  declare -g -A args=()
  declare -g -A deps=()
  declare -g -a env_var_names=()
  declare -g -a input=()

  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "weather") devcli_weather_command ;;
    "build") devcli_build_command ;;
    "local-run") devcli_local_run_command ;;
    "code-scan") devcli_code_scan_command ;;
    "code-scan black") devcli_code_scan_black_command ;;
    "code-scan ash") devcli_code_scan_ash_command ;;
    "code-scan trufflehog") devcli_code_scan_trufflehog_command ;;
    "code-scan mypy") devcli_code_scan_mypy_command ;;
    "code-scan flake8") devcli_code_scan_flake8_command ;;
    "test") devcli_test_command ;;
    "test unit") devcli_test_unit_command ;;
    "test integration") devcli_test_integration_command ;;
    "completions") devcli_completions_command ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  initialize
  run "$@"
fi
